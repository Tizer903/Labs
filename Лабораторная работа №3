# Формируется матрица F следующим образом: если в В количество строк, состоящих из одних нулей в четных столбцах в области 2 больше, чем сумма положительных  элементов в четных строках в области 4, то поменять в С симметрично области 1 и 2 местами, иначе С и Е поменять местами несимметрично. При этом матрица А не меняется. После чего вычисляется выражение: ((К*F)*А– (K * AT) . Выводятся по мере формирования А, F и все матричные операции последовательно
import copy

def read_matrix_from_file(filename):
    with open(filename, 'r', encoding='utf-8') as f:
        return [list(map(int, line.split())) for line in f]

def extract_submatrix(M, n):
    return [row[:n] for row in M[:n]]

def print_matrix(M, title):
    print(f"\n{title}:")
    for r in M:
        print(" ".join(f"{x:6}" for x in r))

def in_area1(i, j, n):
    return j > i and i + j > n - 1
def in_area2(i, j, n):
    return j < i and i + j > n - 1
def in_area3(i, j, n):
    return j < i and i + j < n - 1
def in_area4(i, j, n):
    return j > i and i + j < n - 1

def count_min_in_odd_cols_area2(M, n):
    vals = []
    for i in range(n):
        for j in range(n):
            if in_area2(i, j, n) and (j % 2 == 0):
                vals.append(M[i][j])
    if not vals:
        return 0
    m = min(vals)
    return sum(1 for v in vals if v == m)

def count_max_in_even_rows_area1(M, n):
    vals = []
    for i in range(n):
        for j in range(n):
            if in_area1(i, j, n) and (i % 2 == 1):
                vals.append(M[i][j])
    if not vals:
        return 0
    m = max(vals)
    return sum(1 for v in vals if v == m)

def swap_areas_1_2_symmetrically(F, n):
    for i in range(n):
        for j in range(i+1, n):
            if in_area1(i, j, n) and in_area2(j, i, n):
                F[i][j], F[j][i] = F[j][i], F[i][j]

def swap_areas_2_3_nonsymmetric(F, n):
    area2_coords, area3_coords = [], []
    for i in range(n):
        for j in range(n):
            if in_area2(i, j, n):
                area2_coords.append((i, j))
            elif in_area3(i, j, n):
                area3_coords.append((i, j))
    for (i2, j2), (i3, j3) in zip(area2_coords, area3_coords):
        F[i2][j2], F[i3][j3] = F[i3][j3], F[i2][j2]

def transpose(M):
    n = len(M)
    return [[M[j][i] for j in range(n)] for i in range(n)]

def matmul(A, B):
    n = len(A)
    return [[sum(A[i][k]*B[k][j] for k in range(n)) for j in range(n)] for i in range(n)]

def matscale(M, k):
    return [[k*x for x in row] for row in M]

def matsum(A, B):
    n = len(A)
    return [[A[i][j]+B[i][j] for j in range(n)] for i in range(n)]

K = int(input("Введите число K: "))
N = int(input("Введите число N: "))

try:
    file_matrix = read_matrix_from_file("matrix.txt")
    if len(file_matrix) < N or any(len(row) < N for row in file_matrix):
        raise ValueError("Файл содержит матрицу меньшего размера, чем требуется.")
    A = extract_submatrix(file_matrix, N)
except Exception as e:
    print(f"Ошибка чтения матрицы: {e}")
    raise SystemExit

print_matrix(A, "Матрица A (исходная). A НЕ меняется")

F = copy.deepcopy(A)
c_min_area2 = count_min_in_odd_cols_area2(F, N)
c_max_area1 = count_max_in_even_rows_area1(F, N)

print(f"\nМин. в нечётных столбцах обл.2: {c_min_area2}")
print(f"Макс. в чётных строках обл.1:   {c_max_area1}")

if c_min_area2 > c_max_area1:
    print(f"Меняем 1↔2 симметрично по главной диагонали, потому что {c_min_area2} > {c_max_area1}")
    swap_areas_1_2_symmetrically(F, N)
else:
    print(f"Меняем 2↔3 несимметрично (попарная перестановка координат), потому что {c_min_area2} <= {c_max_area1}")
    swap_areas_2_3_nonsymmetric(F, N)

print_matrix(F, "Матрица F (после перестановки)")

AA = matmul(A, A)
print_matrix(AA, "A*A")

AT = transpose(A)
print_matrix(AT, "A^T")

KAT = matscale(AT, K)
print_matrix(KAT, "K*A^T")

RES = matsum(AA, KAT)
print_matrix(RES, "Результат: A*A + (K*A^T)")

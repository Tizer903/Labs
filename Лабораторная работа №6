import math              # математические функции, здесь нужен factorial
import timeit            # точное измерение времени выполнения кода
import pandas as pd      # удобный вывод таблицы результатов
import matplotlib.pyplot as plt  # построение графиков


# ---------------- РЕКУРСИВНЫЙ ВАРИАНТ ----------------

def F_recursive(n: int) -> float:
    """
    Рекурсивное вычисление F(n) по заданной рекуррентной формуле.
    Область определения: натуральные n (n >= 1).
    """
    if n <= 0:                      # проверка корректности аргумента
        raise ValueError("n должно быть натуральным (n >= 1)")

    if n <= 2:                      # базовый случай: F(1) = F(2) = 10
        return 10.0

    # (-1)^n реализуем через знак, без возведения в степень
    sign = -1.0 if (n % 2 == 1) else 1.0

    # вычисляем факториал (2n + 2)!
    fact = math.factorial(2 * n + 2)

    # рекурсивно считаем F(n-1) и F(n-2)
    f_prev1 = F_recursive(n - 1)
    f_prev2 = F_recursive(n - 2)

    # применяем формулу:
    # F(n) = (-1)^n * (F(n-1) + F(n-2)) / (2n+2)!
    result = sign * (f_prev1 + f_prev2) / fact
    return result


# ---------------- ИТЕРАЦИОННЫЙ ВАРИАНТ (ОПТИМИЗИРОВАННЫЙ) ----------------

def F_iterative(n: int) -> float:
    """
    Итеративное вычисление F(n) с оптимизацией:
    - факториал (2n+2)! на каждом шаге не пересчитывается с нуля,
      а обновляется от предыдущего значения;
    - (-1)^n реализован через переменную sign, которая меняет знак.
    """
    if n <= 0:
        raise ValueError("n должно быть натуральным (n >= 1)")

    # базовые значения F(1) и F(2)
    if n <= 2:
        return 10.0

    # F_prev2 = F(1), F_prev1 = F(2)
    F_prev2 = 10.0
    F_prev1 = 10.0

    # посчитаем (2*2 + 2)! = 6! для n = 2
    fact = 1
    for k in range(1, 6 + 1):
        fact *= k

    # знак для n = 2: (-1)^2 = 1
    sign = 1.0

    # цикл по n от 3 до нужного значения
    for i in range(3, n + 1):
        # обновляем знак: для каждого следующего n знак просто меняется
        # 1, -1, 1, -1, ...
        sign *= -1.0   # теперь sign = (-1)^i

        # для текущего i нужно (2i + 2)!
        # у нас сейчас (2(i-1) + 2)! = (2i)!,
        # поэтому домножаем на (2i+1)*(2i+2),
        # чтобы получить (2i+2)! без пересчёта с нуля
        fact *= (2 * i + 1) * (2 * i + 2)

        # вычисляем F(i) по формуле
        F_curr = sign * (F_prev1 + F_prev2) / fact

        # сдвигаем значения для следующей итерации:
        # F(i-1) становится F_prev2, F(i) -> F_prev1
        F_prev2 = F_prev1
        F_prev1 = F_curr

    # в F_prev1 лежит F(n)
    return F_prev1


# ---------------- СРАВНЕНИЕ ВРЕМЕНИ ВЫЧИСЛЕНИЯ ----------------

if __name__ == "__main__":
    max_n = 20  # при необходимости можно увеличить, чтобы посмотреть рост времени

    results = []  # сюда складываем все результаты для таблицы

    for n in range(1, max_n + 1):
        # значение функции (для контроля совпадения результатов)
        value_rec = F_recursive(n)
        value_itr = F_iterative(n)

        # измеряем время 10 повторений для рекурсии и итерации
        rec_time = timeit.timeit(lambda n=n: F_recursive(n), number=10)
        itr_time = timeit.timeit(lambda n=n: F_iterative(n), number=10)

        results.append((n, value_rec, value_itr, rec_time, itr_time))

    # оформляем результаты в таблицу
    df = pd.DataFrame(
        results,
        columns=[
            "n",
            "F(n) рекурсивно",
            "F(n) итеративно",
            "Время рекурсии (с)",
            "Время итерации (с)",
        ],
    )

    print("=== Сравнение значений и времени вычисления F(n) ===")
    print(df.to_string(index=False))

    # строим график зависимости времени от n
    plt.figure(figsize=(6, 4))
    plt.plot(df["n"], df["Время рекурсии (с)"],
             marker="o", label="Рекурсивный подход")
    plt.plot(df["n"], df["Время итерации (с)"],
             marker="o", label="Итерационный подход")
    plt.xlabel("n")
    plt.ylabel("Время вычисления, с")
    plt.title("Сравнение рекурсивного и итерационного вычисления F(n)")
    plt.grid(True)
    plt.legend()
    plt.tight_layout()
    plt.show()
